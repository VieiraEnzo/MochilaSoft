if(stag == 200){
        vector<Solution> elite_set_solutions;
        elite_set_solutions.reserve(EliteSet_best->getConjSol().size()); // Reserve memory for efficiency
        for (const auto& s : EliteSet_best->getConjSol()) {
            elite_set_solutions.push_back(s); // Add each solution to the vector
        }

        cout << "Elite set best solutions cost: "; 
        for(const auto& e_solution: elite_set_solutions){
          cout << " " << e_solution.cost; 
        }
        cout << endl; 
        const int suporte = min((int)(0.01*(double)_p->num_items), (int) (*EliteSet_best).getESsize());
        Mining miner(*EliteSet_best, suporte, 15);
        miner.map_file();
        miner.mine();
        miner.unmapall_file();
        Pattern **Mined_Patterns = miner.getlistOfPatterns();
        // auto end = std::chrono::high_resolution_clock::now();
        // std::chrono::duration<double> duration = end - start;
        // total_duration += duration;

        int pattern_size = miner.getSizePatterns();

        int randPos = rand()%pattern_size;
        Pattern *Mined_Itens_reused = Mined_Patterns[randPos];
        patterns_reused.push_back(Mined_Itens_reused->elements); 

        vector <vector<int>> pattern_matrix(_p->num_items, vector<int>(pattern_size));
        // cout << "\n========== model called =========="<<endl; 
        for(int i = 0; i < pattern_size; i++){
          // cout << "pattern " << i << ": "; 
          Pattern *Mined_Items = Mined_Patterns[i];
          for(int tmp : Mined_Items->elements){
            // cout << tmp << " "; 
            pattern_matrix[tmp][i] = 1;
          }
          // cout << "\n";
        }
        // cout << "\n\n"; 

        vector <int> elements;
        int num = 0;
        for(bool tmp : best_sol.inside){
          if(tmp == 1){
            elements.push_back(num);
          }
          num += 1;
        }

        Model kpf_model(_p);
        pair<Solution, int> model_result = kpf_model.Build_Model_with_Patterns(_p, pattern_size, pattern_matrix, elements, best_cost);
        solution = model_result.first;
        current_cost = model_result.second;

        cout << "Cost after mining of bests: " << current_cost << endl; 

        if(current_cost == 0){ 
            solution = best_sol;
            current_cost = best_cost;
        }

        if(current_cost > best_cost){
          cout << "solution improved at stag...\n"; 
          best_sol = solution; 
          best_cost = current_cost;
        }
      
        // EliteSet_best.reset(nullptr);
        // EliteSet_best = make_unique<ES>(15);
      }